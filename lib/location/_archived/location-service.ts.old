"use client";

/**
 * Location Service (Client-side)
 * 
 * A utility for handling geolocation with user consent management.
 * This is a pure client-side implementation with no server imports.
 */

import { 
  GeoCoordinates,
  LocationConsentStatus,
  LocationPreferences,
  LocationRequestOptions
} from '@/types/location';

// Cookie constants
const LOCATION_CONSENT_COOKIE = 'location-consent';
const LOCATION_DATA_COOKIE = 'location-data';
const CONSENT_EXPIRY_DAYS = 90; // 3 months

/**
 * Check if browser geolocation API is available
 */
export function isGeolocationAvailable(): boolean {
  return typeof window !== 'undefined' && 'geolocation' in navigator;
}

/**
 * Get location consent status from cookies (client-side)
 */
export function getLocationConsentStatus(): LocationConsentStatus {
  if (typeof window === 'undefined') return 'pending';
  
  try {
    const consentCookie = document.cookie
      .split('; ')
      .find(row => row.startsWith(`${LOCATION_CONSENT_COOKIE}=`));
      
    if (!consentCookie) return 'prompt';
    
    const preferences: LocationPreferences = JSON.parse(
      decodeURIComponent(consentCookie.split('=')[1])
    );
    
    return preferences.consentStatus;
  } catch (error) {
    // Silent error handling - ESLint compliant
    return 'prompt';
  }
}

/**
 * Set location consent status in cookies (client-side)
 */
export function setLocationConsentStatus(
  status: LocationConsentStatus,
  shouldPromptAgain = true
): void {
  if (typeof window === 'undefined') return;
  
  const preferences: LocationPreferences = {
    consentStatus: status,
    consentTimestamp: Date.now(),
    shouldPromptAgain
  };
  
  // Calculate expiry date
  const expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + CONSENT_EXPIRY_DAYS);
  
  document.cookie = `${LOCATION_CONSENT_COOKIE}=${encodeURIComponent(JSON.stringify(preferences))}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Strict`;
}

/**
 * Request user's location with proper error handling (client-side)
 */
export async function getUserLocation(
  options?: LocationRequestOptions
): Promise<GeoCoordinates | null> {
  if (!isGeolocationAvailable()) {
    // Silently handle missing geolocation API
    return null;
  }
  
  const defaultOptions: LocationRequestOptions = {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 0,
    promptIfDenied: false
  };
  
  const geolocationOptions = { ...defaultOptions, ...options };
  
  try {
    // Check if we need to prompt for permission based on current consent status
    const currentStatus = getLocationConsentStatus();
    
    if (currentStatus === 'denied' && !geolocationOptions.promptIfDenied) {
      // User previously denied permission and promptIfDenied is false
      return null;
    }
    
    // Request geolocation from browser
    const position = await new Promise<GeolocationPosition>((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        resolve,
        reject,
        {
          enableHighAccuracy: geolocationOptions.enableHighAccuracy,
          timeout: geolocationOptions.timeout,
          maximumAge: geolocationOptions.maximumAge
        }
      );
    });
    
    // Extract and format coordinates
    const coordinates: GeoCoordinates = {
      latitude: position.coords.latitude,
      longitude: position.coords.longitude,
      accuracy: position.coords.accuracy,
      timestamp: position.timestamp
    };
    
    // Store coordinates in cookies and update consent status
    storeLocationData(coordinates);
    setLocationConsentStatus('granted');
    
    return coordinates;
  } catch (err) {
    // Handle errors silently - let UI display them instead
    if (typeof GeolocationPositionError !== 'undefined' && err instanceof GeolocationPositionError) {
      if (err.code === err.PERMISSION_DENIED) {
        setLocationConsentStatus('denied');
        // Permission denied - will be shown in UI
      }
      // Other geolocation errors handled in the calling component
    }
    // All errors are passed to the UI via Promise rejection
    return null;
  }
}

/**
 * Store location data in a cookie (client-side)
 */
function storeLocationData(coordinates: GeoCoordinates): void {
  if (typeof window === 'undefined') return;
  
  try {
    const expiryDate = new Date();
    expiryDate.setDate(expiryDate.getDate() + 7); // Store for 1 week
    
    document.cookie = `${LOCATION_DATA_COOKIE}=${encodeURIComponent(JSON.stringify({
      ...coordinates,
      lastUpdated: Date.now()
    }))}; expires=${expiryDate.toUTCString()}; path=/; SameSite=Strict`;
  } catch (error) {
    // Silent error handling - ESLint compliant
  }
}

/**
 * Get stored location data from cookies (client-side)
 */
export function getStoredLocation(): GeoCoordinates | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const locationCookie = document.cookie
      .split('; ')
      .find(row => row.startsWith(`${LOCATION_DATA_COOKIE}=`));
      
    if (!locationCookie) return null;
    
    return JSON.parse(decodeURIComponent(locationCookie.split('=')[1]));
  } catch (error) {
    // Silent error handling - ESLint compliant
    return null;
  }
}

/**
 * Clear all location data and consent cookies (client-side)
 */
export function clearLocationData(): void {
  if (typeof window === 'undefined') return;
  
  document.cookie = `${LOCATION_CONSENT_COOKIE}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
  document.cookie = `${LOCATION_DATA_COOKIE}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
}